#pragma once

#include "core/Value.hpp"
#include "core/AST.hpp"

namespace dxsh {
    namespace core {
        class DeferManager {
            inline static DeferManager* inst{};
            
            std::unordered_map<const Expr*, std::optional<Value>> defers;
            
            public:
            // Registers an expression for a deferred value
            // This is used for any value that can only be generated by
            // multiple statements, such as functions
            void DeferExpr(const Expr& expr);

            // Used for storing intermediate results for
            // expressions that were already computed but the statement
            // was not completed (because of the other DeferExpr overload)
            void DeferExpr(const Expr& expr, Value&& value);

            // Returns nullptr if no deferred value was found
            const Value* GetDeferValue(const Expr& expr) const;
            void CleanDeferValue(const Expr& expr);

            static DeferManager& Inst() { return *inst; }
            static void Inst(DeferManager& i) { inst = &i; }
        };

        // This class helps control when an expression's result
        // should be deferred, and when a deferred result should
        // be cleaned up
        class DeferGuard {
            const Expr* expr{};
            Value* value{};
            bool shouldClean = false;

            public:
            DeferGuard() = default;
            // These parameters should never go out of scope while DeferGuard is alive
            // Value is not const to allow the defer manager to move the value into its storage
            DeferGuard(const Expr& expr, Value& val) : expr(&expr), value(&val) { }

            ~DeferGuard();

            DeferGuard(DeferGuard&& move);
            DeferGuard& operator=(DeferGuard&& move);

            DeferGuard(const DeferGuard& copy) = delete;
            DeferGuard& operator=(const DeferGuard&) = delete;

            static void MarkSuccess(std::same_as<DeferGuard> auto&... guards) {
                for (DeferGuard* g : { &guards... }) {
                    g->shouldClean = true;
                }
            }
        };
    }
}